/**
 * HyperAMP å¤šçº¿ç¨‹å®¢æˆ·ç«¯å®ç°
 * 
 * ä½¿ç”¨çº¿ç¨‹æ± å¹¶å‘å‘é€å¤šä¸ªè¯·æ±‚,æµ‹è¯•ç³»ç»Ÿçš„å¹¶å‘å¤„ç†èƒ½åŠ›
 */
    // 3. åˆ†é…å…±äº«å†…å­˜
    char* shm_data =    // 6. å‘é€æ¶ˆæ¯å¹¶é€šçŸ¥(é˜Ÿåˆ—æ“ä½œå·²åŠ é”ä¿æŠ¤)
    struct timespec send_time, recv_time;
    clock_gettime(CLOCK_MONOTONIC, &send_time);
    
    if (client_ops.msg_send_and_notify(amp_client, msg) != 0) {
        printf("[Thread %ld] âŒ ERROR: msg send failed [offset = 0x%x]\n", 
               pthread_self(), msg->offset);
        goto cleanup;
    }
    
    // 7. è½®è¯¢ç­‰å¾…å“åº”ent_ops.shm_malloc(amp_client, request->size + 1, MALLOC_TYPE_P);
    if (shm_data == NULL) {
        shm_data = (char*)client_ops.shm_malloc(amp_client, request->size + 1, MALLOC_TYPE_V);
    }
    if (shm_data == NULL) {
        printf("[Thread %ld] âŒ ERROR: shm malloc failed [size = %u]\n", 
               pthread_self(), request->size + 1);
        goto cleanup;
    }
    
    // 4. é€å­—èŠ‚æ‹·è´æ•°æ®åˆ°å…±äº«å†…å­˜(é¿å…æ€»çº¿é”™è¯¯)
    for (uint32_t i = 0; i < request->size; i++) {
        shm_data[i] = request->data_string[i];
    }
    shm_data[request->size] = '\0';
    
    // 5. è®¾ç½®æ¶ˆæ¯å‚æ•°>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <time.h>
#include "shm/shm.h"
#include "shm/msg.h"
#include "shm/client.h"
#include "shm/threads.h"
#include "shm/config/config_addr.h"
#include "shm/config/config_zone.h"
#include "shm/multithread_client.h"

// ==============================================
// å®¢æˆ·ç«¯è¯·æ±‚ç»“æ„å®šä¹‰
// ==============================================

typedef struct ClientRequest {
    uint32_t request_id;      // è¯·æ±‚ID
    uint32_t service_id;      // æœåŠ¡ID
    char* data_string;        // è¯·æ±‚æ•°æ®
    uint32_t size;            // æ•°æ®å¤§å°
    struct Client* amp_client; // å®¢æˆ·ç«¯æŒ‡é’ˆ(æ‰€æœ‰çº¿ç¨‹å…±äº«)
} ClientRequest;

// ==============================================
// å·¥ä½œçº¿ç¨‹å¤„ç†å‡½æ•°
// ==============================================

/**
 * å¤„ç†å•ä¸ªå®¢æˆ·ç«¯è¯·æ±‚
 * 
 * @param arg1 ClientRequest* è¯·æ±‚ç»“æ„
 * @param arg2 struct Msg* æ¶ˆæ¯ç»“æ„(çº¿ç¨‹ç‹¬å )
 */
static void handle_client_request(void* arg1, void* arg2) {
    ClientRequest* request = (ClientRequest*)arg1;
    struct Msg* msg = (struct Msg*)arg2;
    struct Client* amp_client = request->amp_client;
    
    if (amp_client == NULL) {
        printf("[Thread %ld] âŒ ERROR: Client context not found!\n", pthread_self());
        goto cleanup;
    }
    
    printf("[Thread %ld] ğŸ“¨ Processing request #%u: service=%u, data=\"%s\" (%u bytes)\n",
           pthread_self(), request->request_id, request->service_id, 
           request->data_string, request->size);
    
    // 1. è®¾ç½®æ¶ˆæ¯çš„service_id(é‡è¦!ä¿®å¤Bug #3)
    msg->service_id = request->service_id;
    
    // 2. é‡ç½®æ¶ˆæ¯
    msg_ops.msg_reset(msg);
    
    // 3. åˆ†é…å…±äº«å†…å­˜
    char* shm_data = (char*)client_ops.shm_malloc(amp_client, request->size + 1, MALLOC_TYPE_P);
    if (shm_data == NULL) {
        shm_data = (char*)client_ops.shm_malloc(amp_client, request->size + 1, MALLOC_TYPE_V);
    }
    if (shm_data == NULL) {
        printf("[Thread %ld] âŒ ERROR: shm malloc failed [size = %u]\n", 
               pthread_self(), request->size + 1);
        goto cleanup;
    }
    
    // 4. é€å­—èŠ‚æ‹·è´æ•°æ®åˆ°å…±äº«å†…å­˜(é¿å…æ€»çº¿é”™è¯¯)
    for (uint32_t i = 0; i < request->size; i++) {
        shm_data[i] = request->data_string[i];
    }
    shm_data[request->size] = '\0';
    
    // 5. è®¾ç½®æ¶ˆæ¯å‚æ•°
    msg->offset = client_ops.shm_addr_to_offset(shm_data);
    msg->length = request->size + 1;
    
    // 6. å‘é€æ¶ˆæ¯å¹¶é€šçŸ¥(é˜Ÿåˆ—æ“ä½œå·²åŠ é”ä¿æŠ¤)
    struct timespec send_time, recv_time;
    clock_gettime(CLOCK_MONOTONIC, &send_time);
    
    if (client_ops.msg_send_and_notify(amp_client, msg) != 0) {
        printf("[Thread %ld] âŒ ERROR: msg send failed [offset = 0x%x]\n", 
               pthread_self(), msg->offset);
        goto cleanup;
    }
    
    // 7. è½®è¯¢ç­‰å¾…å“åº”
    while (client_ops.msg_poll(msg) != 0) {
        usleep(100);  // å¾®ç¡çœ å‡å°‘CPUå ç”¨
    }
    
    clock_gettime(CLOCK_MONOTONIC, &recv_time);
    long latency_us = (recv_time.tv_sec - send_time.tv_sec) * 1000000L + 
                      (recv_time.tv_nsec - send_time.tv_nsec) / 1000L;
    
    // 8. æ£€æŸ¥å¤„ç†ç»“æœ
    if (msg->flag.service_result == MSG_SERVICE_RET_SUCCESS) {
        printf("[Thread %ld] âœ… Request #%u SUCCESS - Latency: %ld Î¼s (%.3f ms)\n",
               pthread_self(), request->request_id, latency_us, latency_us / 1000.0);
        
        // æ˜¾ç¤ºå“åº”æ•°æ®(é™åˆ¶æ˜¾ç¤ºé•¿åº¦é¿å…åˆ·å±)
        int display_len = (msg->length - 1 < 64) ? msg->length - 1 : 64;
        printf("[Thread %ld] Response: [", pthread_self());
        for (int i = 0; i < display_len; i++) {
            if (shm_data[i] >= 32 && shm_data[i] <= 126) {
                printf("%c", shm_data[i]);
            } else {
                printf("\\x%02x", (unsigned char)shm_data[i]);
            }
        }
        if ((int)(msg->length - 1) > 64) printf("...");
        printf("]\n");
    } else {
        printf("[Thread %ld] âŒ Request #%u FAILED [service_result = %u]\n", 
               pthread_self(), request->request_id, msg->flag.service_result);
    }
    
    // 9. é‡Šæ”¾å…±äº«å†…å­˜ (é‡è¦!é¿å…å†…å­˜æ³„æ¼)
    if (shm_data != NULL) {
        client_ops.shm_free(amp_client, shm_data);
    }
    
cleanup:
    // æ¸…ç†è¯·æ±‚èµ„æº
    if (request->data_string) free(request->data_string);
    free(request);
}

// ==============================================
// å¤šçº¿ç¨‹å®¢æˆ·ç«¯æµ‹è¯•ä¸»å‡½æ•°
// ==============================================

int hyper_amp_client_test_multithread(int argc, char* argv[]) {
    if (argc < 4) {
        printf("Usage: ./hvisor shm hyper_amp_test_mt <config> <data> <service_id> <threads> [total_requests]\n");
        printf("\n");
        printf("Parameters:\n");
        printf("  config          - SHM configuration file (e.g., shm_config.json)\n");
        printf("  data            - Data to send\n");
        printf("  service_id      - Service ID (1=encrypt, 2=decrypt, 66=echo)\n");
        printf("  threads         - Number of worker threads (1-64)\n");
        printf("  total_requests  - Total requests to send (default: threads)\n");
        printf("\n");
        printf("Examples:\n");
        printf("  ./hvisor shm hyper_amp_test_mt shm_config.json \"hello\" 1 4\n");
        printf("  ./hvisor shm hyper_amp_test_mt shm_config.json \"test\" 1 8 100\n");
        printf("  ./hvisor shm hyper_amp_test_mt shm_config.json \"data\" 66 16 1000\n");
        return -1;
    }
    
    char* config = argv[0];
    char* data_input = argv[1];
    uint32_t service_id = strtoul(argv[2], NULL, 10);
    int num_threads = atoi(argv[3]);
    int num_requests = (argc >= 5) ? atoi(argv[4]) : num_threads;  // é»˜è®¤æ¯çº¿ç¨‹ä¸€ä¸ªè¯·æ±‚
    
    // å‚æ•°æ ¡éªŒ
    if (num_threads <= 0 || num_threads > 64) {
        printf("âŒ ERROR: Invalid thread count %d (must be 1-64)\n", num_threads);
        return -1;
    }
    
    if (num_requests <= 0 || num_requests > 10000) {
        printf("âŒ ERROR: Invalid request count %d (must be 1-10000)\n", num_requests);
        return -1;
    }
    
    // æ˜¾ç¤ºæµ‹è¯•é…ç½®
    printf("\n");
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘     HyperAMP Multi-threaded Client Test               â•‘\n");
    printf("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n");
    printf("â•‘ Configuration: %-39s â•‘\n", config);
    printf("â•‘ Data:          \"%-37s\" â•‘\n", data_input);
    printf("â•‘ Data Size:     %-3zu bytes                             â•‘\n", strlen(data_input));
    printf("â•‘ Service ID:    %-3u                                     â•‘\n", service_id);
    printf("â•‘ Threads:       %-3d workers                            â•‘\n", num_threads);
    printf("â•‘ Total Requests:%-5d                                   â•‘\n", num_requests);
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("\n");
    
    // 1. åˆå§‹åŒ–å…¨å±€åœ°å€é…ç½®
    parse_global_addr(config);
    
    // 2. åˆå§‹åŒ–å…±äº«å®¢æˆ·ç«¯
    struct Client* amp_client = malloc(sizeof(struct Client));
    if (amp_client == NULL) {
        printf("âŒ ERROR: Failed to allocate client\n");
        return -1;
    }
    
    if (client_ops.client_init(amp_client, ZONE_NPUcore_ID) != 0) {
        printf("âŒ ERROR: Client init failed\n");
        free(amp_client);
        return -1;
    }
    printf("âœ… Client initialized (Zone: NPUcore)\n");
    
    // 3. åˆ›å»ºçº¿ç¨‹æ± 
    ThreadPool* pool = init_thread_pool(num_threads, amp_client);
    if (pool == NULL) {
        printf("âŒ ERROR: Failed to create thread pool\n");
        client_ops.client_destory(amp_client);
        free(amp_client);
        return -1;
    }
    printf("âœ… Thread pool created (%d workers)\n", num_threads);
    
    // 4. æäº¤ä»»åŠ¡åˆ°çº¿ç¨‹æ± 
    struct timespec test_start, test_end;
    clock_gettime(CLOCK_MONOTONIC, &test_start);
    
    printf("\nğŸ“¤ Submitting %d requests to thread pool...\n", num_requests);
    int submitted = 0;
    for (int i = 0; i < num_requests; i++) {
        ClientRequest* req = malloc(sizeof(ClientRequest));
        if (req == NULL) {
            printf("âš ï¸  WARNING: Failed to allocate request #%d\n", i + 1);
            continue;
        }
        
        req->request_id = i + 1;
        req->service_id = service_id;
        req->size = strlen(data_input);
        req->data_string = strdup(data_input);
        req->amp_client = amp_client;  // ä¼ é€’å…±äº«å®¢æˆ·ç«¯æŒ‡é’ˆ
        
        if (req->data_string == NULL) {
            printf("âš ï¸  WARNING: Failed to duplicate data for request #%d\n", i + 1);
            free(req);
            continue;
        }
        
        add_task(pool, handle_client_request, req);
        submitted++;
    }
    printf("âœ… Submitted %d/%d requests\n", submitted, num_requests);
    
    // 5. ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    printf("\nâ³ Waiting for all requests to complete...\n");
    while (!task_queue_is_empty(pool)) {
        usleep(100000);  // 100msæ£€æŸ¥ä¸€æ¬¡,é¿å…CPUç©ºè½¬
    }
    
    // é¢å¤–ç­‰å¾…ä¸€å°æ®µæ—¶é—´,ç¡®ä¿æœ€åçš„ä»»åŠ¡å®Œå…¨å¤„ç†å®Œæ¯•
    usleep(500000);  // ç­‰å¾…500msç¡®ä¿æ‰€æœ‰çº¿ç¨‹éƒ½å®Œæˆæ¸…ç†
    
    clock_gettime(CLOCK_MONOTONIC, &test_end);
    long total_time_us = (test_end.tv_sec - test_start.tv_sec) * 1000000L + 
                         (test_end.tv_nsec - test_start.tv_nsec) / 1000L;
    
    // 6. æ˜¾ç¤ºæ€§èƒ½ç»Ÿè®¡
    printf("\n");
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘              Performance Summary                       â•‘\n");
    printf("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n");
    printf("â•‘ Total Time:        %8ld Î¼s (%7.3f ms)           â•‘\n", 
           total_time_us, total_time_us / 1000.0);
    printf("â•‘ Throughput:        %8.2f requests/sec              â•‘\n", 
           submitted * 1000000.0 / total_time_us);
    printf("â•‘ Avg Latency:       %8.2f Î¼s per request            â•‘\n", 
           (double)total_time_us / submitted);
    printf("â•‘ Threads Used:      %8d workers                     â•‘\n", num_threads);
    printf("â•‘ Completed:         %8d/%d requests                â•‘\n", submitted, num_requests);
    
    // æ€§èƒ½è¯„ä¼°
    double throughput = submitted * 1000000.0 / total_time_us;
    if (throughput >= 100) {
        printf("â•‘ Status:            ğŸŸ¢ EXCELLENT (â‰¥100 req/s)          â•‘\n");
    } else if (throughput >= 50) {
        printf("â•‘ Status:            ğŸŸ¡ GOOD (â‰¥50 req/s)                â•‘\n");
    } else if (throughput >= 10) {
        printf("â•‘ Status:            ğŸŸ  ACCEPTABLE (â‰¥10 req/s)          â•‘\n");
    } else {
        printf("â•‘ Status:            ğŸ”´ NEEDS OPTIMIZATION (<10 req/s)  â•‘\n");
    }
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("\n");
    
    // 7. æ¸…ç†èµ„æº
    destroy_thread_pool(pool);
    client_ops.client_destory(amp_client);
    free(amp_client);
    
    printf("âœ… Multi-threaded client test completed successfully!\n\n");
    return 0;
}
